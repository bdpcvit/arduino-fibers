# fiber - легковесные процессы для Arduino

А давайте притащим мир большого программирования в Arduino!

Любая программа, а тем более программа близкая к аппаратуре (а какие еще на arduino бывают?) при рассмотрении представляет собой множество параллельно работающих ветвей.

При этом в реальной жизни обработка **большинства** вещей в реальном времени не требуется. Достаточно иметь нечто похожее на реальное время.

Например если мы программируем скажем гистерезисный регулятор температуры, то как правило совершенно не важно прямо сейчас сработает включатель нагревателя или через пару милисекунд.

А вот если мы программируем скажем регулятор ШИМ (не рассматриваем аппаратные способы), то тут нам возможно потребуется считать каждый такт процессора, чтобы обеспечить приемлемую точность регулирования.

Если рассмотреть структуру произвольного **сложного** программно-аппаратного проекта в том числе на Arduino, то увидим, что задач требующих "реального" (с жесткими требованиями) реалтайма - меньшинство, а большинству задач достаточно условного реалтайма.

Программирование реального реалтайма - это как правило прерывания и аппаратные хитрости. В этой статье поговорим о программировании реалтайма условного.

<cut/>

Давайте представим что мы разрабатываем скажем систему управления обычным бытовым холодильником. Эта система включает в себя:

1. Регулятор температуры
2. Органы управления этой самой температурой (пусть будет переключатель на три положения)
3. Датчик открытия двери
4. Свет в холодильнике
5. Ну и например выход в интернет, куда ж без него.


### Управляем температурой

Давайте попробуем рассмотреть для начала регулятор температуры. Как правило в холодильниках используют гистерезисное регулирование. Мы не будем придумывать велосипед и просто его реализуем.

```c

void
temperature_regulator(void) {

	for (;;) {
		uint16_t current_t = get_adc(INPUT_T);

		if (current_t > t_on)
			enable_cooler();
		
		if (current_t < t_off)
			disable_cooler();
	}
}

```

Где: `t_on` и `t_off` - температуры гистерезиса. `INPUT_T` - вход АЦП измерения температуры. `get_adc` - некая функция производящая измерение АЦП. Функции `enable_cooler` и `disable_cooler` - соответственно включают и выключают охладитель.

Вроде просто?

Рассматривая поближе составляющие сразу натыкаемся на то, что многие вещи включают в себя циклы ожидания. Например функция `get_adc` могла бы выглядеть как-то так:

```c
uint16_t
get_adc(uint8_t input)
{
	adc_switch_mux(input);
	adc_start();
	while (adc_is_busy());
	return adc_value();
}
```

Где `adc_switch_mux` - переключает входной мультиплексор АЦП на нужный вход, `adc_start` запускает АЦП преобразование. Пока преобразование выполняется нам приходится ждать - пустой цикл пока `adc_is_busy` возвращает истину. Когда преобразование выполнится `adc_value` вернет нам результат.

### управляем светом

Управление светом в холодильнике тривиально:

```c
void
light_control(void)
{
	for (;;) {
		if (sensor_door() == DOOR_OPEN)
			light_on();
		else
			light_off();
	}
}
```

О внедрении сюда выключения света по таймеру мы поговорим немного позднее. Сейчас попробуем соединить эти две программы.

Обе программы вполне наглядны понять и написать их сможет школьник. Но как соединить их в один процессор?

Самое простое - преобразовать программы в каллбеки и вызывать их в бесконечном цикле. Именно этот подход предлагает нам Arduino с его традиционной функцией `loop`:

```c
void
temperature_regulator(void) {

	uint16_t current_t = get_adc(INPUT_T);

	if (current_t > t_on)
		enable_cooler();
	
	if (current_t < t_off)
		disable_cooler();
}

void
light_control(void)
{
	if (sensor_door() == DOOR_OPEN)
		light_on();
	else
		light_off();
}


void
loop(void)
{
	temperature_regulator();
	light_control();
	...
}
```

Вроде все просто? Но давайте вернемся к `get_adc`. Просто так уже эта функция не разворачивается. Можно конечно оставить все как есть (АЦП преобразование надолго нас не задержит), для случая холодильника возможно и подойдет, но давайте попробуем развернуть и этот цикл.

Какие сложности возникают:

1. Поскольку имеется возвращаемое значение `get_adc`, то нужно его где-то хранить
2. Если АЦП не используется нигде в другом месте, то у разработчика возникает большой соблазн взять и сунуть измерение АЦП прямо внутрь `temperature_regulator`:

```с

enum adc_state { FREE, BUSY } state;

void
temperature_regulator(void)
{
	uint16_t current_t;
	switch(state) {
		case FREE:
			adc_switch_mux(input);
			adc_start();
			state = BUSY;
			return;
		case BUSY:
			if (adc_is_busy())
				return;
			current_t = adc_value();
			state = FREE;
			break;
	}

	if (current_t > t_on)
		enable_cooler();
	
	if (current_t < t_off)
		disable_cooler();
}
```

Вроде не сильно сложно? Но из неприятностей:

1. появилось внешнее по отношению к функции хранилище состояния АЦП-модуля
2. мы смешали код работы с АЦП с кодом регулятора (инкапсуляция нарушена)
3. если мы АЦП захотим использовать еще в паре мест, то придется тщательно работать над рефакторингом: восстанавливать инкапсуляцию, но при этом придется организовать еще одно хранилище - результаты работы АЦП между вызовами надо где-то хранить.

