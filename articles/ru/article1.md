# fiber - легковесные процессы для Arduino

А давайте притащим мир большого программирования в Arduino!

Любая программа, а тем более программа близкая к аппаратуре (а какие еще на arduino бывают?) при рассмотрении представляет собой множество параллельно работающих ветвей.

При этом в реальной жизни обработка **большинства** вещей в реальном времени не требуется. Достаточно иметь нечто похожее на реальное время.

Например если мы программируем скажем гистерезисный регулятор температуры, то как правило совершенно не важно прямо сейчас сработает включатель нагревателя или через пару милисекунд.

А вот если мы программируем скажем регулятор ШИМ (не рассматриваем аппаратные способы), то тут нам возможно потребуется считать каждый такт процессора, чтобы обеспечить приемлемую точность регулирования.

Если рассмотреть структуру произвольного **сложного** программно-аппаратного проекта в том числе на Arduino, то увидим, что задач требующих "реального" (с жесткими требованиями) реалтайма - меньшинство, а большинству задач достаточно условного реалтайма.

Программирование реального реалтайма - это как правило прерывания и аппаратные хитрости. В этой статье поговорим о программировании реалтайма условного.

<cut/>

Давайте представим что мы разрабатываем скажем систему управления обычным бытовым холодильником. Эта система включает в себя:

1. Регулятор температуры
2. Органы управления этой самой температурой (пусть будет переключатель на три положения)
3. Датчик открытия двери
4. Свет в холодильнике
5. Ну и например выход в интернет, куда ж без него.


### Управляем температурой

Давайте попробуем рассмотреть для начала регулятор температуры. Как правило в холодильниках используют гистерезисное регулирование. Мы не будем придумывать велосипед и просто его реализуем.

```c

void
temperature_regulator(void) {

	for (;;) {
		uint16_t current_t = get_adc(INPUT_T);

		if (current_t > t_on)
			enable_cooler();
		
		if (current_t < t_off)
			disable_cooler();
	}
}

```

Где: `t_on` и `t_off` - температуры гистерезиса. `INPUT_T` - вход АЦП измерения температуры. `get_adc` - некая функция производящая измерение АЦП. Функции `enable_cooler` и `disable_cooler` - соответственно включают и выключают охладитель.

Вроде просто?

Рассматривая поближе составляющие сразу натыкаемся на то, что многие вещи включают в себя циклы ожидания. Например функция `get_adc` могла бы выглядеть как-то так:

```c
uint16_t
get_adc(uint8_t input)
{
	adc_switch_mux(input);
	adc_start();
	while (adc_is_busy());
	return adc_value();
}
```

Где `adc_switch_mux` - переключает входной мультиплексор АЦП на нужный вход, `adc_start` запускает АЦП преобразование. Пока преобразование выполняется нам приходится ждать - пустой цикл пока `adc_is_busy` возвращает истину. Когда преобразование выполнится `adc_value` вернет нам результат.

### управляем светом

Управление светом в холодильнике тривиально:

```c
void
light_control(void)
{
	for (;;) {
		if (sensor_door() == DOOR_OPEN)
			light_on();
		else
			light_off();
	}
}
```

О внедрении сюда выключения света по таймеру мы поговорим немного позднее. Сейчас попробуем соединить эти две программы.

Обе программы вполне наглядны понять и написать их сможет школьник. Но как соединить их в один процессор?

Самое простое - преобразовать программы в каллбеки и вызывать их в бесконечном цикле. Именно этот подход предлагает нам Arduino с его традиционной функцией `loop`:

```c
void
temperature_regulator(void) {

	uint16_t current_t = get_adc(INPUT_T);

	if (current_t > t_on)
		enable_cooler();
	
	if (current_t < t_off)
		disable_cooler();
}

void
light_control(void)
{
	if (sensor_door() == DOOR_OPEN)
		light_on();
	else
		light_off();
}


void
loop(void)
{
	temperature_regulator();
	light_control();
	...
}
```

Вроде все просто? Но давайте вернемся к `get_adc`. Просто так уже эта функция не разворачивается. Можно конечно оставить все как есть (АЦП преобразование надолго нас не задержит), для случая холодильника возможно и подойдет, но давайте попробуем развернуть и этот цикл.

Какие сложности возникают:

1. Поскольку имеется возвращаемое значение `get_adc`, то нужно его где-то хранить
2. Если АЦП не используется нигде в другом месте, то у разработчика возникает большой соблазн взять и сунуть измерение АЦП прямо внутрь `temperature_regulator`:

```c

enum adc_state { FREE, BUSY } state;

void
temperature_regulator(void)
{
	uint16_t current_t;
	switch(state) {
		case FREE:
			adc_switch_mux(input);
			adc_start();
			state = BUSY;
			return;
		case BUSY:
			if (adc_is_busy())
				return;
			current_t = adc_value();
			state = FREE;
			break;
	}

	if (current_t > t_on)
		enable_cooler();
	
	if (current_t < t_off)
		disable_cooler();
}
```

Вроде не сильно сложно? Но из неприятностей:

1. появилось внешнее по отношению к функции хранилище состояния АЦП-модуля
2. мы смешали код работы с АЦП с кодом регулятора (инкапсуляция нарушена)

Если мы АЦП захотим использовать еще в паре мест, то придется тщательно работать над рефакторингом:

- восстанавливать инкапсуляцию (котлеты отдельно, мухи - отдельно)
- организовать еще одно хранилище - результаты работы АЦП между вызовами надо где-то хранить

Итого получается у нас при таком подходе недостатки:

1. Резко возрастает сложность программ
2. Появляются внешние (по отношению к программным сущностям) хранилища данных
3. Либо если мы хотим отказаться от внешних хранилищ данных, появляется протокол обмена данными (каждая функция может вернуть данные или признак их отсутствия. Другие функции будут обрабатывать данные или ничего не делать при их отсутствии.

Если мы решим вывести наш холодильник в интернет, то программирование его в такой парадигме может стать адом.

Как бороться с этим адом?

### Резкое занижение требований к ПО

Это нормальный метод, если он подходит, то можно на нем остановиться. Помните выше мы сформулировали что можно не разворачивать функцию `get_adc`, а оставить как есть.

![И так сойдёт!](articles/ru/article1/soidet.jpg)

Вполне себе работоспособный подход, для холодильника (без сложного интернета) подойдет вполне.

На этом пути по мере наращивания сложности проекта обычно приходится наращивать аппаратную сложность, компенсируя ей сложность программную.

### Треды и процессы

В какой-то момент возникает соблазн даже взять и портировать на нашу систему полноценные треды/процессы. Гугля находим массу проектов, [например вот этот](https://github.com/ivanseidel/ArduinoThread).

[Заглядывая в код треда](https://github.com/ivanseidel/ArduinoThread/blob/master/examples/ControllerInController/ControllerInController.ino#L30) видим все те же калбеки. Разглядывая код поближе - видим попытку организовать периодический вызов функций через примерно равные интервалы.

Например

```c
loop() { ... }
```

Вызывается максимально часто, а вот `Thread.onRun` можно сконфигурировать чтобы вызывался скажем раз в две секунды.

Реальных тредов в том понимании как их понимают в "большом" мире я не нашел. Буду благодарен, если кто-то подбросит мне ссылку на такой проект.

Однако в рамках обсуждения тредов и процессов скажу еще что в "большом" мире для решения задач треды обычно не применяют.
Почему? Реализация тредов (процессов) неизбежно приводит нас к введению понятия "квант времени": каждый тред/процесс выполняется определенный квант времени, после чего управление у него отнимается и передается другому треду/процессу.

Такая многозадачность называется вытесняющей: текущий процесс вытесняется следующим.

Почему в рамках "больших" проектов треды в основном не применяются? Для того чтобы заставить работать множество тредов на одном CPU необходимо делать очень маленький квант времени. Частота квантования например на современном Linux - равна 1000Гц. То есть если у Вас в системе выполняется 1000 процессов одновременно, то каждый из них будет получать 1 квант времени на 1мс один раз в секунду (это если оверхеда на вытеснение нет), а в реальном мире переключая 1000 процессов хорошо если получится выдать каждому по милисекунде раз в десять секунд.

Кроме того, поскольку многозадачность вытесняющая, то возникает масса вопросов по межпроцессному взаимодействию.
