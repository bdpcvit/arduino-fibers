# fiber - легковесные процессы для Arduino

А давайте притащим мир большого программирования в Arduino!

Любая программа, а тем более программа близкая к аппаратуре (а какие еще на arduino бывают?) при рассмотрении представляет собой множество параллельно работающих ветвей.

При этом в реальной жизни обработка **большинства** вещей в реальном времени не требуется. Достаточно иметь нечто похожее на реальное время.

Например если мы программируем скажем гистерезисный регулятор температуры, то как правило совершенно не важно прямо сейчас сработает включатель нагревателя или через пару милисекунд.

А вот если мы программируем скажем регулятор ШИМ (не рассматриваем аппаратные способы), то тут нам возможно потребуется считать каждый такт процессора, чтобы обеспечить приемлемую точность регулирования.

Если рассмотреть структуру произвольного **сложного** программно-аппаратного проекта в том числе на Arduino, то увидим, что задач требующих "реального" (с жесткими требованиями) реалтайма - меньшинство, а большинству задач достаточно условного реалтайма.

Программирование реального реалтайма - это как правило прерывания и аппаратные хитрости. В этой статье поговорим о программировании реалтайма условного.

<cut/>

Давайте представим что мы разрабатываем скажем систему управления обычным бытовым холодильником. Эта система включает в себя:

1. Регулятор температуры
2. Органы управления этой самой температурой (пусть будет переключатель на три положения)
3. Датчик открытия двери
4. Свет в холодильнике
5. Ну и например выход в интернет, куда ж без него.


### Управляем температурой

Давайте попробуем рассмотреть для начала регулятор температуры. Как правило в холодильниках используют гистерезисное регулирование. Мы не будем придумывать велосипед и просто его реализуем.

```c

void
temperature_regulator(void) {

	for (;;) {
		uint16_t current_t = get_adc(INPUT_T);

		if (current_t > t_on)
			enable_cooler();
		
		if (current_t < t_off)
			disable_cooler();
	}
}

```

Где: `t_on` и `t_off` - температуры гистерезиса. `INPUT_T` - вход АЦП измерения температуры. `get_adc` - некая функция производящая измерение АЦП. Функции `enable_cooler` и `disable_cooler` - соответственно включают и выключают охладитель.

Вроде просто?

Рассматривая поближе составляющие сразу натыкаемся на то, что многие вещи включают в себя циклы ожидания. Например функция `get_adc` могла бы выглядеть как-то так:

```c
uint16_t
get_adc(uint8_t input)
{
	adc_switch_mux(input);
	adc_start();
	while (adc_is_busy());
	return adc_value();
}
```

Где `adc_switch_mux` - переключает входной мультиплексор АЦП на нужный вход, `adc_start` запускает АЦП преобразование. Пока преобразование выполняется нам приходится ждать - пустой цикл пока `adc_is_busy` возвращает истину. Когда преобразование выполнится `adc_value` вернет нам результат.

### управляем светом

Управление светом в холодильнике тривиально:

```c
void
light_control(void)
{
	for (;;) {
		if (sensor_door() == DOOR_OPEN)
			light_on();
		else
			light_off();
	}
}
```

О внедрении сюда выключения света по таймеру мы поговорим немного позднее. Сейчас попробуем соединить эти две программы.

Обе программы вполне наглядны понять и написать их сможет школьник. Но как соединить их в один процессор?

Самое простое - преобразовать программы в каллбеки и вызывать их в бесконечном цикле. Именно этот подход предлагает нам Arduino с его традиционной функцией `loop`:

```c
void
temperature_regulator(void) {

	uint16_t current_t = get_adc(INPUT_T);

	if (current_t > t_on)
		enable_cooler();
	
	if (current_t < t_off)
		disable_cooler();
}

void
light_control(void)
{
	if (sensor_door() == DOOR_OPEN)
		light_on();
	else
		light_off();
}


void
loop(void)
{
	temperature_regulator();
	light_control();
	...
}
```

Вроде все просто? Но давайте вернемся к `get_adc`. Просто так уже эта функция не разворачивается. Можно конечно оставить все как есть (АЦП преобразование надолго нас не задержит), для случая холодильника возможно и подойдет, но давайте попробуем развернуть и этот цикл.

Какие сложности возникают:

1. Поскольку имеется возвращаемое значение `get_adc`, то нужно его где-то хранить
2. Если АЦП не используется нигде в другом месте, то у разработчика возникает большой соблазн взять и сунуть измерение АЦП прямо внутрь `temperature_regulator`:

```c

enum adc_state { FREE, BUSY } state;

void
temperature_regulator(void)
{
	uint16_t current_t;
	switch(state) {
		case FREE:
			adc_switch_mux(input);
			adc_start();
			state = BUSY;
			return;
		case BUSY:
			if (adc_is_busy())
				return;
			current_t = adc_value();
			state = FREE;
			break;
	}

	if (current_t > t_on)
		enable_cooler();
	
	if (current_t < t_off)
		disable_cooler();
}
```

Вроде не сильно сложно? Но из неприятностей:

1. появилось внешнее по отношению к функции хранилище состояния АЦП-модуля
2. мы смешали код работы с АЦП с кодом регулятора (инкапсуляция нарушена)

Если мы АЦП захотим использовать еще в паре мест, то придется тщательно работать над рефакторингом:

- восстанавливать инкапсуляцию (котлеты отдельно, мухи - отдельно)
- организовать еще одно хранилище - результаты работы АЦП между вызовами надо где-то хранить

Итого получается у нас при таком подходе недостатки:

1. Резко возрастает сложность программ
2. Появляются внешние (по отношению к программным сущностям) хранилища данных
3. Либо если мы хотим отказаться от внешних хранилищ данных, появляется протокол обмена данными (каждая функция может вернуть данные или признак их отсутствия. Другие функции будут обрабатывать данные или ничего не делать при их отсутствии.

Если мы решим вывести наш холодильник в интернет, то программирование его в такой парадигме может стать адом.

Как бороться с этим адом?

### Резкое занижение требований к ПО

Это нормальный метод, если он подходит, то можно на нем остановиться. Помните выше мы сформулировали что можно не разворачивать функцию `get_adc`, а оставить как есть.

![И так сойдёт!](article1/soidet.jpg)

Вполне себе работоспособный подход, для холодильника (без сложного интернета) подойдет вполне.

На этом пути по мере наращивания сложности проекта обычно приходится наращивать аппаратную сложность, компенсируя ей сложность программную.

### Треды и процессы

В какой-то момент возникает соблазн даже взять и портировать на нашу систему полноценные треды/процессы. Гугля находим массу проектов, [например вот этот](https://github.com/ivanseidel/ArduinoThread).

[Заглядывая в код треда](https://github.com/ivanseidel/ArduinoThread/blob/master/examples/ControllerInController/ControllerInController.ino#L30) видим все те же колбеки. Разглядывая код поближе - видим попытку организовать периодический вызов функций через примерно равные интервалы.

Например

```c
loop() { ... }
```

Вызывается максимально часто, а вот `Thread.onRun` можно сконфигурировать чтобы вызывался скажем раз в две секунды.

Реальных тредов в том понимании как их понимают в "большом" мире я не нашел. Буду благодарен, если кто-то подбросит мне ссылку на такой проект.

Однако в рамках обсуждения тредов и процессов скажу еще что в "большом" мире для решения задач треды обычно не применяют.
Почему? Реализация тредов (процессов) неизбежно приводит нас к введению понятия "квант времени": каждый тред/процесс выполняется определенный квант времени, после чего управление у него отнимается и передается другому треду/процессу.

Такая многозадачность называется вытесняющей: текущий процесс вытесняется следующим.

Почему в рамках "больших" проектов треды в основном не применяются? Для того чтобы заставить работать множество тредов на одном CPU необходимо делать очень маленький квант времени. Частота квантования например на современном Linux - равна 1000Гц. То есть если у Вас в системе выполняется 1000 процессов одновременно, то каждый из них будет получать 1 квант времени на 1мс один раз в секунду (это если оверхеда на вытеснение нет), а в реальном мире переключая 1000 процессов хорошо если получится выдать каждому по милисекунде раз в десять секунд.

Кроме того, поскольку многозадачность вытесняющая, то возникает масса вопросов по межпроцессному взаимодействию. Возились с гонками между прерыванием Arduino и основной программой? И здесь те же проблемы.

В общем все нагруженные, так называемые HighLoad проекты в "большом" мире делают без массового использования тредов. Проекты HighLoad делают с применением кооперативной, а не вытесняющей многозадачности.

### Кооперативная многозадачность

Что это такое? Вот типовой `loop()` проекта Arduino и есть один из вариантов кооперативной многозадачности: переключение к следующей функции не произойдет до тех пор пока она не завершится. Все функции стараемся писать чтобы они возвращали управление максимально быстро и таким способом решаем задачу.

Этот способ реализации кооперативной многозадачности можно называть колбечным (или функциональным).
Если обратиться к "большому" миру, там есть проекты для HighLoad построенные исключительно на этом способе, например тот же [Node.JS](https://nodejs.org/en/).

Если Вы почитаете отзывы о Node.JS, то увидите весь набор от восторженных "наконец я нашел инструмент на котором МОЖНО реализовать мою задачу", до типовых: "callback hell!".

Существует второй способ реализации кооперативной многозадачности - сопрограммы (корутины, файберы). Идея тут примерно такая же как в традиционных тредах: каждый процесс работает как бы независимо от других. Однако ключевое отличие тут в том, что переключение между процессами производится не по таймеру, а тогда, когда сам процесс решит что ему процессор больше не нужен.

Какие прелести дает подобный подход?

1. Нет ада функций;
2. Межпроцессное взаимодействие очень простое (ведь если процесс не прервут в критической секции, то и само понятие "критическая секция" нивелируется): мютексы, семафоры - все или резко упрощается или заменяется простыми переменными;

"Лучшие умы человечества" (ц) разрабатывавшие в прошлом веке для нас язык C и писавшие о нем книги по которым многие из нас учились читать, попытались обобщить все достоинства и тредов и кооперативной нефункциональной многозадачности и в итоге родился язык для HighLoad - Go.

Но впрочем давайте вернемся из большого мира в наш мир Arduino. Go у нас нет, поэтому будем работать с тем что есть.

Итак нам нужны:

1. Возможность создать процесс;
2. Возможность переключиться на другой процесс из процесса.

Традиционное название функции переключения между процессами - `yield` или `cede`.

Вернемся к нашей функции `get_adc`:
 
```c
uint16_t
get_adc(uint8_t input)
{
	adc_switch_mux(input);
	adc_start();
	while (adc_is_busy());
	return adc_value();
}
```

Если бы у нас были кооперативные процессы, то в их среде ее бы следовало доработать до следующего вида:


```c
uint16_t
get_adc(uint8_t input)
{
	adc_switch_mux(input);
	adc_start();
	while (adc_is_busy())
		cede();			// пока ждем - пусть другие работают
	return adc_value();
}
```

Температурный регулятор выглядел бы так:

```c

void
temperature_regulator(void) {

	for (;;) {
		uint16_t current_t = get_adc(INPUT_T);

		if (current_t > t_on)
			enable_cooler();
		
		if (current_t < t_off)
			disable_cooler();
	}
}

```

Но позвольте! Тут же никаких изменений нет! Скажете Вы. А все изменения вошли в `get_adc`, зачем нам еще?

Ну и управление светом тоже доработаем:


```c
void
light_control(void)
{
	for (;;) {
		if (sensor_door() == DOOR_OPEN)
			light_on();
		else
			light_off();

		cede(); // сам поработал - дай другому
	}
}
```
