# fiber - легковесные процессы для Arduino

## Введение

Данная библиотека представляет возможность запуска нескольких
"параллельно" (невытесняющая многозадачность) выполняющихся процессов
на arduino.

Библиотека включает в себя средства создания и коммуникации с файберами.

### Статусы процессов

Каждый процесс может находиться в одном из статусов

* `'r'` (от `ready`) - выполняется в настоящее время;
* `'s'` (от `scheduled`) - выполнение временно прекращено;
* `'d'` (от `dead`) - умер (функция процесса выполнила `return`);
* `'c'` (от `cancelled`) - прекращен вызовом `fiber_cancel`.


Процессов в статусе "выполняется" (`'r'`) в системе может быть от нуля
до какого-то количества. Ноль по сути означает DeadLock, однако штатно
обрабатывается: система переходит в бесконечный цикл ожидая появления
нового процесса в `'r'` статусе (например прерывание может
вызывать `fiber_wakeup` и такой процесс появится).


## Что НЕЛЬЗЯ делать

1. Вызывать любые функции (кроме `fiber_wakeup`) из обработчиков прерывания.

## Пример

Например мы хотим реализовать несколько инверторов: читающих что-то на одном
входе и выдающих инвертированный результат на другой выход.

Пример инвертора:

```c
void
invertor(void *)
{
	for(;;) {
		if (digitalRead(inPIN))
			digitalWrite(outPIN, LOW);
		else
			digitalWrite(outPIN, HIGH);
	}
}
```

Теперь допустим мы хотим запустить пять аналогичных инверторов в системе.

В отсутствие системы управления процессами нам придется:

1. Развернуть алгоритм каждого инвертора в `callback`
2. вызывать все callback из главного цикла:

```c
void
invertor1(void *)
{
	if (digitalRead(inPIN1))
		digitalWrite(outPIN1, LOW);
	else
		digitalWrite(outPIN1, HIGH);
}
...

for (;;) {
	invertor1();
	...
	invertorX();
}

```

Такой подход работает, если логика работы одного элемента простейшая.
Как в данном примере.
Если же между входом и выходом появляется скажем некая машина с памятью
или действие этой машины зависит от времени, то сразу возникает
куча вопросов:

1. передача состояния машины между вызовами callback
2. реализация алгоритмов ветвления (в том числе ветки с "ошибками") на callback

Поэтому сложные вещи программировать на каллбеках сложно. Алгоритм, описывающий
задачу в "плоском" виде кодом размером с экран-два текста на каллбеках занимает
в десятки раз больше и соответственно крайне сложно отлаживается.



```c

#include <fiber.h>

void
invertor(void *)
{
	for(;;) {
		if (digitalRead(inPIN))
			digitalWrite(outPIN, LOW);
		else
			digitalWrite(outPIN, HIGH);
		fiber_cede();
	}
}

void
setup(void)
{
	...
	fiber_init();


	FIBER_CREATE(invertor, 64);
}


void
loop(void)
{
	fiber_cede();
}
```

## Общая инициализация

```c

#include <fiber.h>

void
setup(void)
{
	...
	fiber_init();
}

```

Главный процесс при этом преобразуется в "файбер", получает статус "выполняется".

Данная функция не производит никаких глобальных изменений: просто заполняет
внутренние структуры.

